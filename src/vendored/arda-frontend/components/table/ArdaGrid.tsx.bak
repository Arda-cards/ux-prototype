'use client';

import React, {
  forwardRef,
  useImperativeHandle,
  useRef,
  useCallback,
  useEffect,
  useState,
} from 'react';
import { AgGridReact } from 'ag-grid-react';
import { ModuleRegistry, AllCommunityModule } from 'ag-grid-community';
import {
  ColDef,
  GridApi,
  GridReadyEvent,
  GridOptions,
  SelectionChangedEvent,
  SortChangedEvent,
  RowClickedEvent,
} from 'ag-grid-community';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-alpine.css';

// Register AG-Grid modules
ModuleRegistry.registerModules([AllCommunityModule]);

// Import Arda theme styles
import './ArdaGrid.css';

export interface ArdaGridRef {
  getGridApi: () => GridApi | null;
  refreshData: () => void;
  getSelectedRows: () => unknown[];
  selectAll: () => void;
  deselectAll: () => void;
  exportDataAsCsv: () => void;
  exportDataAsExcel: () => void;
}

export interface ArdaGridProps<T = any> {
  // Data
  rowData: T[];

  // Column configuration
  columnDefs: ColDef<T>[];
  defaultColDef?: ColDef<T>;

  // Grid options
  gridOptions?: GridOptions<T>;

  // Data loading states
  loading?: boolean;
  error?: string | null;

  // Selection
  enableRowSelection?: boolean;
  enableMultiRowSelection?: boolean;
  onSelectionChanged?: (selectedRows: T[]) => void;
  selectedItems?: T[]; // External selection tracking
  totalSelectedCount?: number; // Total count of selected items across all pages
  maxItemsSeen?: number; // Maximum number of items seen across all pages (for accumulated range display)

  // Sorting
  enableSorting?: boolean;
  enableMultiSort?: boolean;
  onSortChanged?: (sortModel: any) => void;

  // Filtering
  enableFiltering?: boolean;
  onFilterChanged?: (filterModel: any) => void;

  // Row actions
  enableRowActions?: boolean;
  rowActions?: Array<{
    label: string;
    icon?: React.ReactNode;
    onClick: (rowData: T) => void;
  }>;

  // Persistence
  enableColumnStatePersistence?: boolean;
  persistenceKey?: string;
  onColumnStateChange?: (columnState: any[]) => boolean | void; // Callback to check if we should save state

  // Server-side data
  onGridReady?: (params: GridReadyEvent<T>) => void;

  // Styling
  className?: string;
  height?: string | number;

  // Callbacks
  onRowClicked?: (rowData: T) => void;
  onRowDoubleClicked?: (rowData: T) => void;

  // Pagination
  paginationData?: {
    currentIndex: number;
    currentPageSize: number;
    totalItems: number;
    currentPage: number;
    hasNextPage: boolean;
    hasPreviousPage: boolean;
  };
  onNextPage?: () => void;
  onPreviousPage?: () => void;
  onFirstPage?: () => void;
  onLastPage?: () => void;
}

const ArdaGrid = forwardRef<ArdaGridRef, ArdaGridProps>(
  (
    {
      rowData,
      columnDefs,
      defaultColDef,
      gridOptions = {},
      loading = false,
      error = null,
      enableRowSelection = true,
      enableMultiRowSelection = true,
      onSelectionChanged,
      selectedItems = [],
      totalSelectedCount,
      maxItemsSeen,
      enableSorting = true,
      enableMultiSort = true,
      onSortChanged,
      enableFiltering = true,
      onFilterChanged,
      enableRowActions = false,
      rowActions = [],
      enableColumnStatePersistence = true,
      persistenceKey = 'arda-grid-state',
      onColumnStateChange,
      onGridReady,
      className = '',
      height = '100%',
      onRowClicked,
      onRowDoubleClicked,
      paginationData,
      onNextPage,
      onPreviousPage,
      onFirstPage,
      onLastPage,
    },
    ref
  ) => {
    const gridRef = useRef<AgGridReact>(null);
    const [gridApi, setGridApi] = useState<GridApi | null>(null);
    const isApplyingPersistedStateRef = useRef(false);
    const previousPersistenceKeyRef = useRef<string | undefined>(
      persistenceKey
    );

    // Expose imperative API
    useImperativeHandle(ref, () => ({
      getGridApi: () => gridApi,
      refreshData: () => {
        if (gridApi) {
          gridApi.refreshCells();
        }
      },
      getSelectedRows: () => {
        if (gridApi) {
          return gridApi.getSelectedRows();
        }
        return [];
      },
      selectAll: () => {
        if (gridApi) {
          gridApi.selectAll();
        }
      },
      deselectAll: () => {
        if (gridApi) {
          gridApi.deselectAll();
        }
      },
      exportDataAsCsv: () => {
        if (gridApi) {
          gridApi.exportDataAsCsv();
        }
      },
      exportDataAsExcel: () => {
        if (gridApi) {
          gridApi.exportDataAsExcel();
        }
      },
    }));

    // Handle grid ready
    const handleGridReady = useCallback(
      (params: GridReadyEvent) => {
        setGridApi(params.api);

        // Initialize the previous persistence key ref
        previousPersistenceKeyRef.current = persistenceKey;

        // Load persisted column state and sort model
        // Apply immediately to avoid visual lag
        if (enableColumnStatePersistence) {
          const savedState = localStorage.getItem(persistenceKey);
          if (savedState) {
            try {
              const persistedState = JSON.parse(savedState);

              // Apply persisted state immediately to avoid visual lag
              const applyPersistedState = () => {
                // Set flag to prevent saving state while applying persisted state
                isApplyingPersistedStateRef.current = true;

                // Handle backward compatibility: if it's an array, it's the old format
                if (Array.isArray(persistedState)) {
                  // Clean pinned property: no columns should be pinned
                  const cleanedState = persistedState.map((col: any) => {
                    return {
                      ...col,
                      pinned: null,
                    };
                  });

                  // Apply with order immediately
                  params.api.applyColumnState({
                    state: cleanedState,
                    applyOrder: true,
                  });

                  // Clear flag after a short delay
                  setTimeout(() => {
                    isApplyingPersistedStateRef.current = false;
                  }, 100);
                } else {
                  // New format: object with columnState and sortModel
                  if (
                    persistedState.columnState &&
                    Array.isArray(persistedState.columnState)
                  ) {
                    // Merge sort model into column state if it exists
                    let columnStateToApply = persistedState.columnState;

                    if (
                      persistedState.sortModel &&
                      Array.isArray(persistedState.sortModel) &&
                      persistedState.sortModel.length > 0
                    ) {
                      // Create a map of sort by colId for quick lookup
                      const sortMap = new Map(
                        persistedState.sortModel.map((sort: any) => [
                          sort.colId,
                          sort,
                        ])
                      );

                      // Merge sort information into column state
                      columnStateToApply = persistedState.columnState.map(
                        (col: any) => {
                          const sortInfo = sortMap.get(col.colId) as
                            | { sort: string; sortIndex?: number }
                            | undefined;
                          if (sortInfo) {
                            return {
                              ...col,
                              sort: sortInfo.sort,
                              sortIndex: sortInfo.sortIndex,
                            };
                          }
                          return col;
                        }
                      );
                    }

                    // Clean pinned property: no columns should be pinned
                    const cleanedState = columnStateToApply.map((col: any) => {
                      return {
                        ...col,
                        pinned: null,
                      };
                    });

                    // Apply column state with order
                    if (cleanedState.length > 0) {
                      params.api.applyColumnState({
                        state: cleanedState,
                        applyOrder: true,
                        defaultState: { sort: null },
                      });

                      // Clear flag after a delay to ensure state is fully applied
                      // Use a longer delay to prevent any events from triggering saves
                      setTimeout(() => {
                        isApplyingPersistedStateRef.current = false;
                      }, 1500); // Increased to 1.5 seconds to ensure all events have processed
                    } else {
                      isApplyingPersistedStateRef.current = false;
                    }
                  }
                }
              };

              // Apply state with a delay to ensure columns are fully initialized
              // When component remounts (e.g., navigating back from dashboard), columns need time to be ready
              setTimeout(() => {
                applyPersistedState();
              }, 200);
            } catch (error) {
              console.warn('Failed to load persisted grid state:', error);
            }
          }
        }

        onGridReady?.(params);
      },
      [enableColumnStatePersistence, persistenceKey, onGridReady]
    );

    // Apply persisted state when persistenceKey changes (e.g., when switching tabs)
    // Only apply when the key actually changes, not on every render
    useEffect(() => {
      if (!gridApi || !enableColumnStatePersistence) {
        return;
      }

      // Only apply if persistenceKey actually changed (tab switch)
      if (previousPersistenceKeyRef.current === persistenceKey) {
        return;
      }

      // Update the ref to track the current key
      previousPersistenceKeyRef.current = persistenceKey;

      const applyPersistedState = () => {
        const savedState = localStorage.getItem(persistenceKey);
        if (savedState) {
          try {
            const persistedState = JSON.parse(savedState);

            // Set flag to prevent saving while applying persisted state
            isApplyingPersistedStateRef.current = true;

            const applyState = (retryCount = 0) => {
              // Ensure columns are available and grid is ready
              const columns = gridApi.getColumns();

              if (!columns || columns.length === 0) {
                // Retry up to 30 times (1.5 seconds total) to ensure columns are ready
                if (retryCount < 30) {
                  setTimeout(() => applyState(retryCount + 1), 50);
                } else {
                  isApplyingPersistedStateRef.current = false;
                }
                return;
              }

              // Also check if we have at least some column definitions
              if (columns.length < 2) {
                // Not enough columns yet, retry
                if (retryCount < 30) {
                  setTimeout(() => applyState(retryCount + 1), 50);
                } else {
                  isApplyingPersistedStateRef.current = false;
                }
                return;
              }

              if (Array.isArray(persistedState)) {
                // Old format: array of column states
                const cleanedState = persistedState
                  .filter((col: any) => col.colId)
                  .map((col: any) => ({
                    ...col,
                    pinned: null,
                  }));

                if (cleanedState.length > 0) {
                  gridApi.applyColumnState({
                    state: cleanedState,
                    applyOrder: true,
                  });
                }
              } else if (
                persistedState.columnState &&
                Array.isArray(persistedState.columnState)
              ) {
                // New format: object with columnState
                let columnStateToApply = persistedState.columnState.filter(
                  (col: any) => col.colId
                );

                if (
                  persistedState.sortModel &&
                  Array.isArray(persistedState.sortModel) &&
                  persistedState.sortModel.length > 0
                ) {
                  const sortMap = new Map(
                    persistedState.sortModel.map((sort: any) => [
                      sort.colId,
                      sort,
                    ])
                  );
                  columnStateToApply = columnStateToApply.map((col: any) => {
                    const sortInfo = sortMap.get(col.colId) as
                      | { sort: string; sortIndex?: number }
                      | undefined;
                    if (sortInfo) {
                      return {
                        ...col,
                        sort: sortInfo.sort,
                        sortIndex: sortInfo.sortIndex,
                      };
                    }
                    return col;
                  });
                }

                const cleanedState = columnStateToApply.map((col: any) => ({
                  ...col,
                  pinned: null,
                }));

                if (cleanedState.length > 0) {
                  gridApi.applyColumnState({
                    state: cleanedState,
                    applyOrder: true,
                    defaultState: { sort: null },
                  });
                } else {
                  console.warn(
                    `[GRID_PERSISTENCE] No columns to apply (cleanedState is empty)`
                  );
                }
              }

              // Clear flag after a delay to ensure all events have processed
              // Use a longer delay to prevent interfering with column moves
              setTimeout(() => {
                isApplyingPersistedStateRef.current = false;
              }, 1500); // Increased to 1.5 seconds to ensure state is fully applied and doesn't interfere with moves
            };

            // Apply immediately - the retry logic will handle if columns aren't ready
            applyState();
          } catch (error) {
            console.warn(
              'Failed to load persisted grid state on key change:',
              error
            );
            isApplyingPersistedStateRef.current = false;
          }
        } else {
          // If no saved state, ensure flag is cleared
          isApplyingPersistedStateRef.current = false;
        }
      };

      // Apply persisted state when key changes
      applyPersistedState();
    }, [gridApi, enableColumnStatePersistence, persistenceKey]);

    // Handle selection changes
    const handleSelectionChanged = useCallback(
      (event: SelectionChangedEvent) => {
        const selectedRows = event.api.getSelectedRows();
        onSelectionChanged?.(selectedRows);
      },
      [onSelectionChanged]
    );

    // Handle sort changes
    const handleSortChanged = useCallback(
      (event: SortChangedEvent) => {
        const sortModel = event.api.getColumnState();
        onSortChanged?.(sortModel);
      },
      [onSortChanged]
    );

    // Handle filter changes
    const handleFilterChanged = useCallback(
      (event: any) => {
        const filterModel = event.api.getFilterModel();
        onFilterChanged?.(filterModel);
      },
      [onFilterChanged]
    );

    // Save column state and sort model when they change
    useEffect(() => {
      if (gridApi && enableColumnStatePersistence) {
        const saveGridState = () => {
          // Small delay to ensure the state is fully updated
          setTimeout(() => {
            // Don't save if we're applying persisted state
            if (isApplyingPersistedStateRef.current) {
              return;
            }

            // Get the full column state - this has the correct order and all properties
            const fullColumnState = gridApi.getColumnState();
            if (!fullColumnState || fullColumnState.length === 0) return;

            // Use getColumnState() directly - it already has the correct order and all properties
            const columnState = fullColumnState.map((col: any) => ({
              ...col,
              colId: col.colId,
              pinned: null, // Ensure no columns are pinned
            }));

            // Check if we should save (e.g., if updating from props, don't save)
            if (onColumnStateChange) {
              const result = onColumnStateChange(columnState);
              if (
                result === false ||
                (result === undefined && isApplyingPersistedStateRef.current)
              ) {
                return;
              }
            }

            // Extract sort model from column state (columns with sort defined)
            const sortModel = columnState
              .filter((col: any) => col.sort !== null && col.sort !== undefined)
              .map((col: any) => ({
                colId: col.colId,
                sort: col.sort,
                sortIndex: col.sortIndex,
              }));

            const gridState = {
              columnState,
              sortModel,
            };

            localStorage.setItem(persistenceKey, JSON.stringify(gridState));
          }, 50);
        };

        // Handler for column moves - save state preserving the current order
        // Use the same pattern as handleColumnVisible for consistency
        const handleColumnMoved = () => {
          // Save state preserving the current order
          // Use a small delay to ensure the move is complete
          setTimeout(() => {
            // Don't save if we're applying persisted state
            if (isApplyingPersistedStateRef.current) {
              return;
            }

            // Get the full column state - this has the correct order and all properties
            const fullColumnState = gridApi.getColumnState();
            if (!fullColumnState || fullColumnState.length === 0) return;

            // Use getColumnState() directly - it already has the correct order and all properties
            const columnState = fullColumnState.map((col: any) => ({
              ...col,
              colId: col.colId,
              pinned: null, // Ensure no columns are pinned
            }));

            // Check if we should save
            if (onColumnStateChange) {
              const result = onColumnStateChange(columnState);
              if (result === false) {
                return;
              }
            }

            // Don't save if we're applying persisted state
            if (isApplyingPersistedStateRef.current) {
              return;
            }

            // Extract sort model from column state
            const sortModel = columnState
              .filter((col: any) => col.sort !== null && col.sort !== undefined)
              .map((col: any) => ({
                colId: col.colId,
                sort: col.sort,
                sortIndex: col.sortIndex,
              }));

            const gridState = {
              columnState,
              sortModel,
            };

            localStorage.setItem(persistenceKey, JSON.stringify(gridState));
          }, 50);
        };

        // Handler for column visibility changes - preserve order when hiding/showing
        const handleColumnVisible = () => {
          // Save state preserving the current order
          // Use a small delay to ensure visibility change is complete
          setTimeout(() => {
            // Don't save if we're applying persisted state
            if (isApplyingPersistedStateRef.current) {
              return;
            }

            // Get the full column state - this has the correct order and all properties
            const fullColumnState = gridApi.getColumnState();
            if (!fullColumnState || fullColumnState.length === 0) return;

            // Use getColumnState() directly - it already has the correct order and all properties
            const columnState = fullColumnState.map((col: any) => ({
              ...col,
              colId: col.colId,
              pinned: null, // Ensure no columns are pinned
            }));

            // Check if we should save
            if (onColumnStateChange) {
              const result = onColumnStateChange(columnState);
              if (result === false) {
                return;
              }
            }

            // Don't save if we're applying persisted state
            if (isApplyingPersistedStateRef.current) {
              return;
            }

            // Extract sort model from column state
            const sortModel = columnState
              .filter((col: any) => col.sort !== null && col.sort !== undefined)
              .map((col: any) => ({
                colId: col.colId,
                sort: col.sort,
                sortIndex: col.sortIndex,
              }));

            const gridState = {
              columnState,
              sortModel,
            };

            localStorage.setItem(persistenceKey, JSON.stringify(gridState));
          }, 50);
        };

        // Handler for column moves - use EXACTLY the same function as handleColumnVisible
        // This ensures column order persistence works exactly like visibility persistence
        const handleColumnMoved = handleColumnVisible;

        // Save when columns are resized
        gridApi.addEventListener('columnResized', saveGridState);

        // Save when visibility changes (preserving order)
        gridApi.addEventListener('columnVisible', handleColumnVisible);

        // Save immediately when columns are moved - uses same handler as visibility
        gridApi.addEventListener('columnMoved', handleColumnMoved);

        // Save when sorting changes
        gridApi.addEventListener('sortChanged', saveGridState);

        return () => {
          gridApi.removeEventListener('columnResized', saveGridState);
          gridApi.removeEventListener('columnVisible', handleColumnVisible);
          gridApi.removeEventListener('columnMoved', handleColumnMoved);
          gridApi.removeEventListener('sortChanged', saveGridState);
        };
      }
    }, [
      gridApi,
      enableColumnStatePersistence,
      persistenceKey,
      onColumnStateChange,
    ]);

    // Default column definition
    const defaultColumnDef: ColDef = {
      sortable: enableSorting,
      filter: enableFiltering,
      resizable: true,
      suppressHeaderMenuButton: true,
      suppressMovable: false,
      ...defaultColDef,
    };

    // Grid options with Arda theme
    const mergedGridOptions: GridOptions = {
      // Theme - use legacy theme to avoid conflicts with CSS files
      theme: 'legacy',

      // Selection
      rowSelection: enableRowSelection
        ? enableMultiRowSelection
          ? 'multiple'
          : 'single'
        : undefined,
      suppressRowClickSelection: true, // Always suppress row click selection - only checkbox should select

      // Sorting
      multiSortKey: enableMultiSort ? 'ctrl' : undefined,

      // Styling
      headerHeight: 48,
      rowHeight: 48,

      // Performance
      suppressColumnVirtualisation: false,
      suppressRowVirtualisation: false,

      // Column dragging
      suppressColumnMoveAnimation: true,

      // Use entityId as stable row ID for proper selection tracking
      getRowId: (params) => {
        // Try common id fields from data
        const data = params.data as any;
        if (data?.entityId) return data.entityId;
        if (data?.id) return data.id;
        if (data?.eId) return data.eId;
        // Fallback: generate unique ID based on data
        return `row-${JSON.stringify(data).slice(0, 50)}`;
      },

      // Default cell renderer for actions
      defaultColDef: defaultColumnDef,

      ...gridOptions,
    };

    // Add row actions column if enabled
    const finalColumnDefs =
      enableRowActions && rowActions.length > 0
        ? [
            ...columnDefs,
            {
              headerName: 'Actions',
              field: 'actions',
              width: 120,
              pinned: 'right',
              sortable: false,
              filter: false,
              resizable: false,
              cellRenderer: (params: any) => {
                return (
                  <div className='flex items-center gap-1'>
                    {rowActions.map((action, index) => (
                      <button
                        key={index}
                        className='p-1 hover:bg-gray-100 rounded'
                        onClick={() => action.onClick(params.data)}
                        title={action.label}
                      >
                        {action.icon || action.label}
                      </button>
                    ))}
                  </div>
                );
              },
            } as ColDef,
          ]
        : columnDefs;

    // Loading overlay
    const loadingOverlay = loading ? (
      <div className='flex items-center justify-center h-full'>
        <div className='animate-spin rounded-full h-8 w-8 border-b-2 border-orange-500'></div>
      </div>
    ) : null;

    // Error overlay
    const errorOverlay = error ? (
      <div className='flex items-center justify-center h-full text-red-500'>
        <div className='text-center'>
          <p className='text-lg font-semibold'>Error loading data</p>
          <p className='text-sm'>{error}</p>
        </div>
      </div>
    ) : null;

    // Wrap row click handler to prevent opening panel when clicking checkbox
    const handleRowClicked = useCallback(
      (event: RowClickedEvent) => {
        if (!onRowClicked) return;

        // Ensure event.data exists
        if (!event.data) {
          console.warn('Row click event has no data');
          return;
        }

        // Check if the click target is a checkbox or inside a checkbox cell
        const nativeEvent = event.event;
        if (nativeEvent) {
          const target = nativeEvent.target as HTMLElement;

          // Check if clicking directly on a checkbox
          if (
            target?.tagName === 'INPUT' &&
            (target as HTMLInputElement).type === 'checkbox'
          ) {
            return;
          }

          // Check if clicking inside the checkbox column cell
          if (target?.closest('.ag-cell[col-id="select"]')) {
            return;
          }

          // Check if clicking inside any element with col-id="select"
          if (target?.closest('[col-id="select"]')) {
            return;
          }

          // Check if clicking inside the quickActions column cell
          if (target?.closest('.ag-cell[col-id="quickActions"]')) {
            return;
          }

          // Check if clicking inside any element with col-id="quickActions"
          if (target?.closest('[col-id="quickActions"]')) {
            return;
          }

          // Check if clicking inside the notes column cell
          if (target?.closest('.ag-cell[col-id="notes"]')) {
            return;
          }

          // Check if clicking inside any element with col-id="notes"
          if (target?.closest('[col-id="notes"]')) {
            return;
          }
        }

        // Safe to call the row click handler with the row data
        onRowClicked(event.data);
      },
      [onRowClicked]
    );

    return (
      <div className={`arda-grid-container ${className}`} style={{ height }}>
        {/* Grid */}
        <div className='ag-theme-arda h-full'>
          <AgGridReact
            ref={gridRef}
            rowData={rowData}
            columnDefs={finalColumnDefs}
            defaultColDef={defaultColumnDef}
            gridOptions={mergedGridOptions}
            onGridReady={handleGridReady}
            onSelectionChanged={handleSelectionChanged}
            onSortChanged={handleSortChanged}
            onFilterChanged={handleFilterChanged}
            onRowClicked={handleRowClicked}
            onRowDoubleClicked={onRowDoubleClicked}
            loadingOverlayComponent={loadingOverlay}
            noRowsOverlayComponent={errorOverlay}
          />

          {/* Pagination Controls - integrated as table footer row */}
          {paginationData && (
            <div className='ag-pagination-footer'>
              <div className='pagination-content'>
                {/* Range display */}
                <div className='pagination-range'>
                  <span className='font-bold'>
                    {totalSelectedCount !== undefined
                      ? totalSelectedCount
                      : selectedItems.length}
                  </span>{' '}
                  to{' '}
                  <span className='font-bold'>
                    {maxItemsSeen !== undefined
                      ? maxItemsSeen
                      : rowData.length > 0
                      ? Math.min(
                          paginationData.currentIndex + rowData.length,
                          paginationData.totalItems
                        )
                      : paginationData.totalItems}
                  </span>
                </div>

                {/* Navigation controls */}
                <div className='pagination-controls'>
                  {/* First page button */}
                  <button
                    onClick={onFirstPage}
                    disabled={!paginationData.hasPreviousPage}
                    className='pagination-button'
                    title='First page'
                  >
                    K
                  </button>

                  {/* Previous page button */}
                  <button
                    onClick={onPreviousPage}
                    disabled={!paginationData.hasPreviousPage}
                    className='pagination-button'
                    title='Previous page'
                  >
                    &lt;
                  </button>

                  {/* Page indicator */}
                  <div className='pagination-page-info'>
                    Page{' '}
                    <span className='font-bold'>
                      {paginationData.currentPage}
                    </span>{' '}
                    of{' '}
                    <span className='font-bold'>
                      {Math.ceil(
                        paginationData.totalItems /
                          paginationData.currentPageSize
                      )}
                    </span>
                  </div>

                  {/* Next page button */}
                  <button
                    onClick={onNextPage}
                    disabled={!paginationData.hasNextPage}
                    className='pagination-button'
                    title='Next page'
                  >
                    &gt;
                  </button>

                  {/* Last page button */}
                  <button
                    onClick={onLastPage}
                    disabled={!paginationData.hasNextPage}
                    className='pagination-button'
                    title='Last page'
                  >
                    &gt;|
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    );
  }
);

ArdaGrid.displayName = 'ArdaGrid';

export default ArdaGrid;
