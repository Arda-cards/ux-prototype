import { Meta } from '@storybook/blocks';

<Meta title="Docs/Use Cases" />

# Use Cases

Use cases demonstrate end-to-end user workflows by composing components and application mocks into realistic scenarios with interaction tests.

## Hierarchy

Use cases follow a three-level hierarchy:

```
Feature Area > Workflow > Scenario
```

For example:

```
Onboarding > Account Setup > Happy Path
Onboarding > Account Setup > Validation Error
Dashboard  > Data Export   > CSV Download
```

Each scenario maps to a set of artifacts inside `src/use-cases/`.

## Artifacts

A complete use case consists of four artifacts:

<table>
  <thead>
    <tr><th>Artifact</th><th>File</th><th>Purpose</th></tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Description</strong></td>
      <td><code>*.mdx</code></td>
      <td>Product-manager-level specification of the use case: user story, workflow steps, field definitions, acceptance criteria, and sample data. Written in plain language — serves as the single source of truth and as input for AI-assisted code generation.</td>
    </tr>
    <tr>
      <td><strong>Interactive story</strong></td>
      <td rowspan="3"><code>*.stories.tsx</code></td>
      <td>Hands-on exploration — the user fills in real data and clicks through the workflow. A guide panel shows contextual help.</td>
    </tr>
    <tr>
      <td><strong>Stepwise story</strong></td>
      <td>Guided demo — the app advances one pre-filled scene at a time via story controls. Useful for walkthroughs and design reviews.</td>
    </tr>
    <tr>
      <td><strong>Automated story</strong></td>
      <td>Regression test — a <code>play</code> function exercises the full workflow end-to-end. Executed by <code>@storybook/test-runner</code> via Playwright.</td>
    </tr>
  </tbody>
</table>

The Description page appears in the Storybook sidebar alongside the story variants, giving reviewers immediate access to the specification without leaving the tool.

## Writing the Description (MDX)

The Description is the **first artifact** to create. It should be detailed enough that an AI agent (or a developer unfamiliar with the codebase) can generate the remaining story artifacts from it alone.

### Required sections

The Description follows the standard user story template (`workspace/instructions/how-to-and-templates/user-story.md`), adapted for Storybook MDX:

<table>
  <thead>
    <tr><th>Section</th><th>Content</th></tr>
  </thead>
  <tbody>
    <tr><td><strong>Header</strong></td><td><code># Feature Area: Story Title</code> plus metadata (Author, Date, Priority, Feature Version, Related Issue).</td></tr>
    <tr><td><strong>User Story</strong></td><td><em>As a…, I want to…, so that…</em> format.</td></tr>
    <tr><td><strong>Context</strong></td><td>Business context — why this workflow exists, what downstream features depend on it, and any preconditions.</td></tr>
    <tr><td><strong>Acceptance Criteria</strong></td><td><strong>Given / When / Then</strong> checkboxes that map directly to automated story expectations.</td></tr>
    <tr><td><strong>Error Scenarios</strong></td><td>Given / When / Then for invalid inputs or error states. For happy-path-only stories, note that errors are covered separately.</td></tr>
    <tr><td><strong>UI/UX Notes</strong></td><td>Page reference, step-by-step field tables, UI behavior notes, responsive considerations.</td></tr>
    <tr><td><strong>Dependencies</strong></td><td>Upstream (what must exist first) and downstream (what depends on this).</td></tr>
    <tr><td><strong>Out of Scope</strong></td><td>Explicitly list what this use case does <em>not</em> cover.</td></tr>
    <tr><td><strong>Notes</strong></td><td>Sample data (matching the <code>SAMPLE</code> constant in stories), story artifacts table, and any additional context.</td></tr>
  </tbody>
</table>

### Template

```mdx
import { Meta } from '@storybook/blocks';

<Meta title="Use Cases/Feature Area/Workflow/Description" />

# Feature Area: Story Title

**Author**: Product Owner
**Date**: YYYY-MM-DD
**Priority**: Critical | High | Medium | Low
**Feature Version**: MVP1
**Related Issue**: <a href="https://github.com/Arda-cards/management/issues/NNN" target="_blank">#NNN</a>

## User Story

As a **user persona**,
I want to **action/goal**,
so that **benefit/value**.

## Context

Business context, how this fits into the broader feature,
and any relevant domain knowledge.

**Preconditions:**

- Condition 1
- Condition 2

## Acceptance Criteria

- [ ] **Given** precondition, **when** action, **then** expected result.
- [ ] **Given** precondition, **when** action, **then** expected result.

## Error Scenarios

- [ ] **Given** invalid input or state, **when** action, **then** expected error behavior.

## UI/UX Notes

**Page:** Module > Page Name

**Key interactions:**

Step-by-step workflow description with field tables and UI behavior notes.

**Responsive considerations:** Notes or "Not addressed in this use case."

## Dependencies

- **Upstream**: Features or stories that must be completed before this one.
- **Downstream**: Features or stories that depend on this one.

## Out of Scope

- Exclusion 1
- Exclusion 2

## Notes

### Sample Data

A code block with the canonical test values.

### Story Artifacts

Table of Interactive / Stepwise / Automated stories.
```

> **Note:** Use HTML `<table>` elements instead of markdown tables — markdown tables do not render correctly inside Storybook MDX files. Use `&amp;` instead of `&`, `&#215;` instead of `&times;`, `&#8805;` instead of `&ge;`, and avoid bare curly braces in text (MDX interprets them as JSX expressions).

## Story Modes

Every use case should provide **three story exports** so that different audiences can engage with the workflow in the way that suits them best:

<table>
  <thead>
    <tr><th>Story</th><th>Purpose</th><th>User interaction</th></tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Interactive</strong></td>
      <td>Hands-on exploration — the user fills in real data and clicks through the wizard themselves.</td>
      <td>Full interaction with application controls (inputs, buttons, dropdowns).</td>
    </tr>
    <tr>
      <td><strong>Stepwise</strong></td>
      <td>Guided walkthrough — the application advances one scene at a time with pre-filled data. Ideal for demos and design reviews.</td>
      <td>Only the story controls (<em>Next</em>, <em>Previous</em>, <em>Reset</em>). Application controls are non-interactive.</td>
    </tr>
    <tr>
      <td><strong>Automated</strong></td>
      <td>End-to-end regression test — a <code>play</code> function exercises the entire workflow programmatically.</td>
      <td>None — runs automatically. Executed by <code>@storybook/test-runner</code> via Playwright.</td>
    </tr>
  </tbody>
</table>

### Guide Panel

Both the **Interactive** and **Stepwise** stories display a **Guide Panel** below the application content. The panel is visually separated from the app (blue left border, tinted background) and contains:

- **Description** — what the current step is about and what is happening on screen.
- **Expected interaction** — what a real user would do at this point in the workflow.

In Interactive mode the guide updates automatically as the user navigates the wizard. In Stepwise mode the guide updates when the viewer clicks Next / Previous.

### Story Controls (Stepwise only)

The Stepwise story renders a **Story Control Bar** below the guide panel with:

- **Previous / Next** buttons to move between scenes.
- **Scene counter** showing the current position (e.g. "Scene 3 of 9").
- **Reset** button to return to the first scene.

The application content is rendered read-only (`pointer-events: none`) so the user cannot accidentally interact with form controls while stepping through.

## Use Case Framework

All story chrome — step indicators, guide panels, story controls, viewers — is provided by a shared framework at `src/use-cases/framework.tsx`. Authors only declare **data, guides, scenes, step content, and a play function**. The framework handles everything else.

### What the framework provides

<table>
  <thead>
    <tr><th>Export</th><th>Kind</th><th>Purpose</th></tr>
  </thead>
  <tbody>
    <tr><td><code>createUseCaseStories</code></td><td>Factory</td><td>Generates <code>meta</code>, <code>Interactive</code>, <code>Stepwise</code>, and <code>Automated</code> story objects from a single config.</td></tr>
    <tr><td><code>useWizard</code></td><td>Hook</td><td>Manages wizard state (step, form data, submitted flag) and returns a control surface for <code>UseCaseShell</code>.</td></tr>
    <tr><td><code>UseCaseShell</code></td><td>Component</td><td>Renders the heading, step indicator, navigation buttons, guide panel, and reset link. Wraps your step content.</td></tr>
    <tr><td><code>FormField</code></td><td>Component</td><td>Labeled text/number input with consistent styling.</td></tr>
    <tr><td><code>FormSelect</code></td><td>Component</td><td>Labeled dropdown select.</td></tr>
    <tr><td><code>FormRow</code></td><td>Component</td><td>Side-by-side grid for grouping fields on one row.</td></tr>
    <tr><td><code>SummaryCard</code></td><td>Component</td><td>Bordered card for review-step summaries.</td></tr>
    <tr><td><code>SummaryRow</code></td><td>Component</td><td>Label/value row inside a summary card.</td></tr>
    <tr><td><code>Divider</code></td><td>Component</td><td>Horizontal rule for separating summary sections.</td></tr>
    <tr><td><code>SuccessScreen</code></td><td>Component</td><td>Centered confirmation with check icon, badges, details card, and reset button.</td></tr>
    <tr><td><code>formatCurrency</code></td><td>Utility</td><td>Formats a number as US currency with thousands separator.</td></tr>
    <tr><td><code>GuideEntry</code>, <code>Scene</code>, <code>WizardProps</code>, <code>PlayContext</code></td><td>Types</td><td>TypeScript interfaces for guides, scenes, wizard props, and the play callback context.</td></tr>
  </tbody>
</table>

## Creating a Use Case

### 1. Create the directory and Description

```
src/use-cases/feature-area/workflow/
  workflow.mdx              ← Description (create first)
  scenario.stories.tsx      ← Story implementation (single file)
```

Start by writing the Description MDX following the template above. The Description should be complete and reviewed before story implementation begins — it serves as the spec for both human developers and AI agents.

### 2. Define form data and sample values

Derive the typed interface and `SAMPLE` constant directly from the Description's field tables and Sample Data section. All field values are stored as `string` (even numbers) since they bind to HTML inputs:

```tsx
interface FormData {
  name: string;
  email: string;
  role: string;
}

const INITIAL: FormData = { name: '', email: '', role: '' };

const SAMPLE: FormData = {
  name: 'Jane Smith',
  email: 'jane@example.com',
  role: 'Admin',
};
```

### 3. Define guides and scenes

**Guides** describe each wizard phase (one per step + one for the success screen). Derive these from the Workflow section of the Description:

```tsx
const guides: GuideEntry[] = [
  {
    title: 'Step 1: Account Details',
    description: 'Enter name, email, and role...',
    interaction: 'Fill in all fields, then click "Next Step".',
  },
  // ...one per step, plus a final "Success" entry
];
```

**Scenes** are snapshots for the Stepwise and Automated viewers. Each scene captures the wizard state at a specific moment and includes guide text. Derive these by breaking each Workflow step into individual field-fill actions:

```tsx
const scenes: Scene<FormData>[] = [
  {
    wizardStep: 0,
    submitted: false,
    formData: INITIAL,
    title: 'Scene 1 of 5 — Empty Form',
    description: 'The form starts empty...',
    interaction: 'The user types a name.',
  },
  {
    wizardStep: 0,
    submitted: false,
    formData: { ...INITIAL, name: SAMPLE.name },
    title: 'Scene 2 of 5 — Name Entered',
    description: 'Name is filled, email still empty...',
    interaction: 'The user enters their email.',
  },
  // ...one per discrete moment through to success
];
```

### 4. Build the wizard component

Use `useWizard` for state management and `UseCaseShell` for chrome. You only write the **step content** (form fields and review layout):

```tsx
function MyWizard(props: WizardProps<FormData>) {
  const w = useWizard(props, {
    initial: INITIAL,
    stepNames: ['Account Details', 'Preferences', 'Review'],
    canAdvance: (step, data) => {
      if (step === 0) return !!(data.name && data.email && data.role);
      if (step === 1) return !!data.preferences;
      return true;
    },
  });

  return (
    <UseCaseShell
      wizard={w}
      guides={guides}
      heading="Create Account"
      subtitle="Complete each step to set up your account."
      submitLabel="Confirm"
      success={
        <SuccessScreen
          title="Account created"
          subtitle={<>Welcome, <strong>{w.formData.name}</strong>!</>}
          onReset={w.handleReset}
        />
      }
    >
      {w.step === 0 && (
        <>
          <FormField label="Name" name="name" value={w.formData.name}
            onChange={w.handleChange} />
          <FormField label="Email" name="email" value={w.formData.email}
            onChange={w.handleChange} />
          <FormSelect label="Role" name="role" value={w.formData.role}
            onChange={w.handleChange} options={['Admin', 'User']}
            placeholder="Select a role" />
        </>
      )}
      {w.step === 1 && (
        <FormField label="Preferences" name="preferences"
          value={w.formData.preferences} onChange={w.handleChange} />
      )}
      {w.step === 2 && (
        <SummaryCard>
          <SummaryRow label="Name" value={w.formData.name} />
          <SummaryRow label="Email" value={w.formData.email} />
        </SummaryCard>
      )}
    </UseCaseShell>
  );
}
```

The `useWizard` hook manages step navigation, form state, reset, and submission. The `UseCaseShell` renders the heading, step indicator, Back/Next buttons, Reset link, and guide panel — you never build these manually.

### 5. Generate and export the stories

Define the `meta` object as a plain object literal (required for Storybook's static analyzer), then call `createUseCaseStories` to generate all three story variants:

```tsx
import type { Meta } from '@storybook/react';
import { expect, userEvent } from '@storybook/test';
import {
  createUseCaseStories, useWizard, UseCaseShell,
  FormField, FormSelect, SummaryCard, SummaryRow,
  SuccessScreen, type GuideEntry, type Scene, type WizardProps,
} from '@/use-cases/framework';

// ... FormData, INITIAL, SAMPLE, guides, scenes, MyWizard defined above ...

const meta = {
  title: 'Use Cases/Feature Area/Workflow/Scenario',
  parameters: { layout: 'centered' },
} satisfies Meta;

const { Interactive, Stepwise, Automated } = createUseCaseStories<FormData>({
  guides,
  scenes,
  Wizard: MyWizard,
  delayMs: 2000,  // pause between automated steps (ms)
  play: async ({ canvas, goToScene, delay }) => {
    goToScene(0);
    await delay();

    await userEvent.type(canvas.getByLabelText('Name'), SAMPLE.name);
    goToScene(1);
    await delay();

    // ... continue through each scene ...

    await expect(canvas.getByTestId('success-message'))
      .toHaveTextContent('Account created');
  },
});

export default meta;
export { Interactive, Stepwise, Automated };
```

> **Note:** The `meta` must be a static object literal — Storybook's CSF indexer uses static analysis and cannot resolve values returned from function calls.

The `play` callback receives:
- **`canvas`** — Testing Library scoped queries for the story element.
- **`goToScene(index)`** — updates the Automated viewer's guide panel to match the current scene.
- **`delay()`** — pauses for `delayMs` milliseconds so the viewer can see each step.

That's it — one story file, one wizard component, and the framework handles all three modes.

## AI-Assisted Generation

The Description MDX is intentionally structured to be machine-readable. An AI agent given the Description and the framework import should be able to:

1. **Extract the `FormData` interface** from the field tables (field names, types, required flags).
2. **Generate `INITIAL` and `SAMPLE` constants** from the Sample Data section.
3. **Write `guides`** from the Workflow narrative and "User action" lines (one per step + success).
4. **Write `scenes`** by decomposing each Workflow step into field-by-field snapshots with `formData` state.
5. **Build the wizard component** using `useWizard` + `UseCaseShell` + framework form components (`FormField`, `FormSelect`, `FormRow`, `SummaryCard`, `SummaryRow`, `Divider`, `SuccessScreen`).
6. **Write the `play` function** by mapping each User action to a `userEvent` call and each Acceptance Criterion to an `expect` assertion, with `goToScene` calls to synchronize the guide panel.

When asking an AI agent to implement a use case, provide:
- The Description MDX as the specification
- The framework source (`src/use-cases/framework.tsx`) as the API reference
- An existing implementation (e.g. `src/use-cases/inventory/add-item/happy-path.stories.tsx`) as a structural example

## Mock Data Patterns

- Keep mock data in a `SAMPLE` constant within the story file.
- For complex scenarios with shared data across multiple scenario files, extract to a separate `mock-data.ts`.
- Use realistic but fictional data — never use real user information.
- All form values should be `string` type (even numbers) since they bind to HTML inputs.

## Interaction Testing

### How `play` functions work

The `play` function in a story is an async function that runs after the story renders. In the framework, it receives a `PlayContext` with:

- `canvas` — scoped queries from Testing Library
- `goToScene(index)` — synchronizes the guide panel with the current automation step
- `delay()` — pauses between steps for visibility (configurable via `delayMs`)

### How they run via the test runner

The Storybook test runner (`@storybook/test-runner`) uses Playwright to:

1. Start a headless browser.
2. Navigate to each story in the built Storybook.
3. Execute any `play` function defined on the story.
4. Report pass/fail results.

Run locally:

```bash
# Terminal 1: serve the built Storybook
npm run build-storybook
npx http-server storybook-static --port 6006

# Terminal 2: run the tests
npm run test:storybook
```

In CI, this runs automatically via the `ci.yml` workflow using `concurrently` and `wait-on` to orchestrate the server and test runner.
